#! /usr/bin/env nqp

use NQPHLL;

grammar PHQ::Grammar is HLL::Grammar {
    token TOP {
        :my $*CUR-BLOCK := QAST::Block.new: QAST::Stmts.new;
        ^
        <.shəbang>?
        <statements>
        [ $ || <.panic('Syntax error')> ]
    }

    token shəbang { '#!' \N* \n }

    rule statements {
       <.ws>
       <statement>+ % ';'
       ';'?
    }


    proto token statement {*}

    token statement:sym<EXPR> { <EXPR> }

    rule statement:sym<echo> {
        <sym> [ <?[(]> '(' <EXPR> ')' || <EXPR> ]
    }


    proto token value {*}
    token value:sym<string>  { <?["]> <quote_EXPR: ':q', ':b'> }
    token value:sym<integer> { '-'? \d+ }
    token value:sym<number>  { '-'? \d+ '.' \d+ }


    token term:sym<value> { <value> }
    token term:sym<var> {
        :my $*MAYBE-DECL := 0;
        <varname>
        [  <?before \h* '=' \h* [ <value> | <identifier> ]
                { $*MAYBE-DECL := 1 }>
        || <?>
        ]
    }
    token varname { '$' <.identifier> }
    token identifier { <[_ A..Z a..z]> <[_ A..Z a..z 0..9]>* }

    # Operators
    my %multiplicative := nqp::hash('prec', 'u=', 'assoc', 'left');
    my %additive       := nqp::hash('prec', 't=', 'assoc', 'left');
    my %concatenation  := nqp::hash('prec', 'r=', 'assoc', 'left');
    my %assignment     := nqp::hash('prec', 'i=', 'assoc', 'right');

    token infix:sym<*>    { <sym>  <O(|%multiplicative, :op<mul_n>)> }
    token infix:sym</>    { <sym>  <O(|%multiplicative, :op<div_n>)> }
    token infix:sym<%>    { <sym>  <O(|%multiplicative, :op<mod_n>)> }
    token infix:sym<+>    { <sym>  <O(|%additive,       :op<add_n>)> }
    token infix:sym<->    { <sym>  <O(|%additive,       :op<sub_n>)> }
    token infix:sym<.>    { <sym>  <O(|%concatenation,  :op<concat>)> }
    token infix:sym<=>    { <sym>  <O(|%assignment,     :op<bind>)> }


    # Whitespace required between word tokens
    token ws { <!ww> <.white>+ || <.white>* }
    token white { \s+ || '//' \N+ \n }
}

class PHQ::Actions is HLL::Actions {
    method TOP($/) {
        $*CUR-BLOCK.push: $<statements>.ast;
        make $*CUR-BLOCK;
    }

    method statements($/) {
        my $stmts := QAST::Stmts.new(:node($/));
        for $<statement> {
            $stmts.push($_.ast);
        }
        make $stmts;
    }


    method statement:sym<EXPR>($/) { make $<EXPR>.ast }

    method statement:sym<echo>($/) {
        make QAST::Op.new:
            :node($/),
            :op<print>,
            $<EXPR>.ast
    }


    method value:sym<string>($/)  { make $<quote_EXPR>.ast }
    method value:sym<integer>($/) { make QAST::IVal.new: :value(+~$/) }
    method value:sym<number>($/)  { make QAST::NVal.new: :value(+~$/) }


    method term:sym<value>($/) { make $<value>.ast }
    method term:sym<var>($/) {
        my $name := ~$<varname>;
        my %sym := $*CUR-BLOCK.symbol($name);
        if $*MAYBE-DECL && !%sym<declared> {
            $*CUR-BLOCK.symbol($name, :declared);
            make QAST::Var.new: :$name, :scope<lexical>, :decl<var>;
        }
        else {
            make QAST::Var.new: :$name, :scope<lexical>;
        }
    }
}

class PHQ::Compiler is HLL::Compiler {
    # This avoids passing @args to $output(), which appears to be a
    # bug in NQP(?). Without this fix, running `./phq test1.phq`
    # errors with:
    # Too many positionals passed; expected 0 arguments but got 1

    # Taken from Pull Request #19:
    # https://github.com/edumentab/rakudo-and-nqp-internals-course/pull/19/commits/f103137e136ffb0dd8014e1ed69e700daac56180

    method eval($code, *@args, *%adverbs) {
        my $output := self.compile($code, :compunit_ok(1), |%adverbs);
        $output := self.backend.compunit_mainline($output);
        $output();
    }
}

sub MAIN(*@ARGS) {
    my $comp := PHQ::Compiler.new();
    $comp.language('phq');
    $comp.parsegrammar(PHQ::Grammar);
    $comp.parseactions(PHQ::Actions);
    $comp.command_line(@ARGS, :encoding<utf8>, :!rxtrace);
}

#:nnoremap <buffer> <Enter> :w<CR> \| :!%:p<CR>
# vim:ft=perl6 sw=4 ts=8 sts=4 et:
