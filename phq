#! /usr/bin/env nqp

use NQPHLL;

grammar PHQ::Grammar is HLL::Grammar {
    token TOP {
        :my $*CUR-BLOCK := QAST::Block.new: QAST::Stmts.new;
        ^
        <.shəbang>?
        <statements>
        [ $ || <.panic('Syntax error')> ]
    }

    token shəbang { '#!' \N* \n }

    rule statements {
        ''
        [ <statement> <.eat-terminator> ]*
    }

    token eat-terminator {
        || ';'
        # No semi-colon needed at end of a block
        || <?MARKED('endstmt')>
        # Or if this is the end of file
        || $
    }


    proto token statement {*}

    token statement:sym<null> { '' <?[;]> }

    rule statement:sym<echo> {
        <sym> [ <?[(]> '(' <EXPR> ')' || <EXPR> ]
    }

    token statement:sym<EXPR> { <EXPR> }

    rule statement:sym<function> {
        <sym>
        <funcname>
        <funcbody>
    }

    rule funcbody {
        :my $*CUR-BLOCK := QAST::Block.new: QAST::Stmts.new;
        '(' <param>* % ',' ')'
        <block>
    }

    token param { <varname> }

    token block {
        '{' <statements> '}' <?ENDSTMT>
    }

    token ENDSTMT {
        [
        <.eol> <.ws> <?MARKER('endstmt')>
        ]?
    }


    proto token value {*}
    token value:sym<string>  { <?["]> <quote_EXPR: ':q', ':b'> }
    token value:sym<integer> { '-'? \d+ }
    token value:sym<number>  { '-'? \d+ '.' \d+ }


    token term:sym<value> { <value> }

    rule term:sym<call> { <funcname> '(' <EXPR>* % ',' ')'}

    rule term:sym<var> {
        :my $*MAYBE-DECL := 0;
        <varname>
        [ <?before '='<![=]> { $*MAYBE-DECL := 1 }> || <?> ]
    }

    token varname { '$' <identifier> }
    token funcname { <!keyword> <.identifier> }
    token identifier { <[_ A..Z a..z]> <[_ A..Z a..z 0..9]>* }

    # Operators
    my %multiplicative := nqp::hash('prec', 'u=', 'assoc', 'left');
    my %additive       := nqp::hash('prec', 't=', 'assoc', 'left');
    my %concatenation  := nqp::hash('prec', 'r=', 'assoc', 'left');
    my %assignment     := nqp::hash('prec', 'i=', 'assoc', 'right');

    token infix:sym<*>    { <sym>  <O(|%multiplicative, :op<mul_n>)> }
    token infix:sym</>    { <sym>  <O(|%multiplicative, :op<div_n>)> }
    token infix:sym<%>    { <sym>  <O(|%multiplicative, :op<mod_n>)> }
    token infix:sym<+>    { <sym>  <O(|%additive,       :op<add_n>)> }
    token infix:sym<->    { <sym>  <O(|%additive,       :op<sub_n>)> }
    token infix:sym<.>    { <sym>  <O(|%concatenation,  :op<concat>)> }
    token infix:sym<=>    { <sym>  <O(|%assignment,     :op<bind>)> }


    # Whitespace required between word tokens
    token ws { <!ww> <.white>* }
    token white { \s+ || <.comment> }
    token comment { '//' \N+ \n }
    token eol { \h* [ \n | <.comment> ] }
    token keyword {
        [
        | if | elseif | else | while | for
        | echo
        ]
        <!ww>
    }
}

class PHQ::Actions is HLL::Actions {
    method TOP($/) {
        $*CUR-BLOCK.push: $<statements>.ast;
        make $*CUR-BLOCK;
    }

    method statements($/) {
        my $stmts := QAST::Stmts.new: :node($/);
        for $<statement> {
            $stmts.push($_.ast);
        }
        make $stmts;
    }


    method statement:sym<null>($/) { make QAST::Op.new: :node($/), :op<null> }

    method statement:sym<function>($/) {
        my $name := ~$<funcname>;
        my $install := $<funcbody>.ast;
        $install.name($name);
        $*CUR-BLOCK[0].push: QAST::Op.new:
            :op<bind>,
            QAST::Var.new(:$name, :scope<lexical>, :decl<var>),
            $install;
        make QAST::Op.new: :node($/), :op<null>;
    }

    method funcbody($/) {
        $*CUR-BLOCK.node($/);
        $*CUR-BLOCK.push($<block><statements>.ast);
        make $*CUR-BLOCK;
    }

    method param($/) {
        $*CUR-BLOCK[0].push: QAST::Var.new:
            :node($/), :name(~$<varname>), :scope<lexical>, :decl<param>;
        $*CUR-BLOCK.symbol(~$<varname>, :declared);
    }

    method statement:sym<EXPR>($/) { make $<EXPR>.ast }

    method statement:sym<echo>($/) {
        make QAST::Op.new:
            :node($/),
            :op<print>,
            $<EXPR>.ast
    }


    method value:sym<string>($/)  { make $<quote_EXPR>.ast }
    method value:sym<integer>($/) { make QAST::IVal.new: :node($/), :value(+~$/) }
    method value:sym<number>($/)  { make QAST::NVal.new: :node($/), :value(+~$/) }


    method term:sym<value>($/) { make $<value>.ast }
    method term:sym<call>($/) {
        my $call := QAST::Op.new: :node($/), :op<call>, :name(~$<funcname>);
        for $<EXPR> {
            $call.push: $_.ast;
        }
        make $call;
    }
    method term:sym<var>($/) {
        my $name := ~$<varname>;
        my %sym := $*CUR-BLOCK.symbol($name);
        if $*MAYBE-DECL && !%sym<declared> {
            $*CUR-BLOCK.symbol($name, :declared);
            make QAST::Var.new: :$name, :scope<lexical>, :decl<var>;
        }
        else {
            make QAST::Var.new: :$name, :scope<lexical>;
        }
    }
}

class PHQ::Compiler is HLL::Compiler {
    # This avoids passing @args to $output(), which appears to be a
    # bug in NQP(?). Without this fix, running `./phq test1.phq`
    # errors with:
    # Too many positionals passed; expected 0 arguments but got 1

    # Taken from Pull Request #19:
    # https://github.com/edumentab/rakudo-and-nqp-internals-course/pull/19/commits/f103137e136ffb0dd8014e1ed69e700daac56180

    method eval($code, *@args, *%adverbs) {
        my $output := self.compile($code, :compunit_ok(1), |%adverbs);
        $output := self.backend.compunit_mainline($output);
        $output();
    }
}

sub MAIN(*@ARGS) {
    my $comp := PHQ::Compiler.new();
    $comp.language('phq');
    $comp.parsegrammar(PHQ::Grammar);
    $comp.parseactions(PHQ::Actions);
    $comp.command_line(@ARGS, :encoding<utf8>, :!rxtrace);
}

#:nnoremap <buffer> <Enter> :w<CR> \| :!%:p<CR>
# vim:ft=perl6 sw=4 ts=8 sts=4 et:
